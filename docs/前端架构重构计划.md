# 优化的前端模块架构设计

## 🏗️ 架构原则

### 1. 分层架构 (基于DDD)
```
presentation/static/js/
├── core/           # 核心基础设施
├── domain/         # 领域模型和业务逻辑  
├── application/    # 应用服务层
├── infrastructure/ # 基础设施
├── ui/            # 界面组件
└── bootstrap/     # 启动和集成
```

### 2. 模块大小控制
- 每个文件不超过 300 行
- 单一职责原则
- 高内聚，低耦合

### 3. 依赖管理
- 明确的依赖关系
- 防止循环依赖
- 延迟加载非关键模块

## 📁 新的文件结构

### Core (核心层)
```
core/
├── module-registry.js      # 模块注册中心 (简化版)
├── event-bus.js           # 事件总线
├── logger.js              # 统一日志
└── constants.js           # 常量定义
```

### Domain (领域层)
```
domain/
├── entities/
│   ├── conversation.js    # 对话实体
│   ├── message.js         # 消息实体
│   └── shop.js           # 店铺实体
├── services/
│   ├── session-service.js # 会话领域服务
│   └── badge-service.js   # 红点领域服务
└── repositories/
    └── interfaces.js      # 仓储接口定义
```

### Application (应用层)
```
application/
├── use-cases/
│   ├── manage-conversation.js # 对话管理用例
│   ├── update-badges.js       # 红点更新用例
│   └── sync-data.js          # 数据同步用例
└── services/
    └── notification-service.js # 通知应用服务
```

### Infrastructure (基础设施层)
```
infrastructure/
├── api/
│   ├── http-client.js     # HTTP客户端
│   └── websocket-client.js # WebSocket客户端
├── storage/
│   └── local-storage.js   # 本地存储
└── repositories/
    ├── conversation-repo.js # 对话仓储实现
    └── shop-repo.js        # 店铺仓储实现
```

### UI (界面层)
```
ui/
├── components/
│   ├── badge.js           # 红点组件
│   ├── conversation-item.js # 对话项组件
│   └── shop-card.js       # 店铺卡片组件
├── containers/
│   ├── conversation-list.js # 对话列表容器
│   └── shop-dashboard.js    # 店铺仪表板容器
└── utils/
    ├── dom-helpers.js     # DOM 工具
    └── ui-helpers.js      # UI 工具
```

### Bootstrap (启动层)
```
bootstrap/
├── app-initializer.js     # 应用初始化器
├── dependency-injection.js # 依赖注入
└── module-loader.js       # 模块加载器
```

## 🔄 重构计划

### 阶段1: 核心基础设施
1. 创建模块注册中心
2. 实现事件总线
3. 统一日志系统

### 阶段2: 领域模型
1. 提取业务实体
2. 定义领域服务
3. 抽象仓储接口

### 阶段3: 应用服务
1. 实现用例
2. 整合业务流程
3. 处理跨模块协调

### 阶段4: 基础设施
1. 实现API客户端
2. 数据存储抽象
3. 仓储具体实现

### 阶段5: 界面重构
1. 组件化UI
2. 容器组件
3. 工具函数

### 阶段6: 启动集成
1. 依赖注入配置
2. 模块启动顺序
3. 错误处理

## ✅ 预期收益

1. **消除重复代码**: 统一的模块注册机制
2. **清晰的职责分离**: 每层有明确的责任
3. **易于测试**: 依赖注入和接口抽象
4. **便于扩展**: 插件化架构
5. **降低复杂度**: 每个文件保持简洁

## 📊 文件大小目标

- 核心模块: ≤ 200 行
- 领域实体: ≤ 150 行  
- 应用服务: ≤ 250 行
- 基础设施: ≤ 300 行
- UI组件: ≤ 200 行
- 启动配置: ≤ 100 行