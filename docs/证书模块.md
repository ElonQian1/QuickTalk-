可以，而且**完全可以做成你项目里的“独立模块”**，不依赖 Certbot/acme.sh 这类外部程序（只用 Rust 库 crate）。下面给你一套**可直接落地**的方案与代码骨架，并说明 **Windows 开发** 与 **Ubuntu 生产**要点差异。

---

# ✅ 方案总览（不依赖外部可执行程序）

* **路 A｜TLS-ALPN-01（推荐用于生产）**
  在同一进程内完成 ACME 下单/验证/自动续期，要求放行 **443 端口**（TLS-ALPN-01 规范强制 443）。集成简单，证书会自动热更新，不需要你去写 TXT。
  适合：Ubuntu 生产机（云服务器可开 443）。

* **路 B｜DNS-01 + DuckDNS（可签通配符，不占 80/443）**
  在代码里直连 **DuckDNS 的 TXT API** 写 `_acme-challenge`，完成验证后取证书，落盘到 `/root/ubuntu-deploy-ready/certs`；然后你的服务器用这些 PEM 启动或热重载。
  适合：家宽/NAT/端口受限，或需要 `*.elontalk.duckdns.org` 通配证书；也可在 **Windows 开发机**上预签发后上传到服务器。

> 两条路都可以**封装成一个独立模块**（比如 `acme` 模块），通过配置 `ACME_MODE=tls-alpn|dns01` 在不同环境切换。

---

## 📦 项目结构（建议）

```
/root/ubuntu-deploy-ready/
└── customer-service-backend/
    ├── Cargo.toml
    └── src/
        ├── main.rs
        ├── acme/
        │   ├── mod.rs            # 统一入口，读取配置，选择 tls-alpn 或 dns01
        │   ├── tls_alpn.rs       # 路 A：内置 ACME（443 自动申请与续期）
        │   └── dns_duckdns.rs    # 路 B：DNS-01 + DuckDNS，签好证后落盘
        └── web.rs                # 你的业务路由/handler
```

---

## 路 A：一体化 TLS-ALPN-01（生产优选）

**依赖（库，不是外部程序）**：

```toml
# Cargo.toml（关键依赖）
[dependencies]
axum = "0.7"
hyper = { version = "1", features = ["http1", "server"] }
tokio = { version = "1", features = ["full"] }
rustls-acme = "0.14"   # 纯Rust ACME 客户端（内置 TLS-ALPN-01 / HTTP-01）
anyhow = "1"
```

```rust
// 文件: src/acme/tls_alpn.rs
//! 在同一进程内跑完 ACME（TLS-ALPN-01），自动申请+自动续期；要求 443 端口。
//! 生产机请确保 A 记录指向本机，且防火墙放行 443。

use axum::{routing::get, Router};
use rustls_acme::{AcmeConfig, caches::DirCache};
use tokio_stream::StreamExt;
use std::{path::PathBuf};
use tokio::net::TcpListener;
use anyhow::Result;

pub async fn run_tls_alpn_server(domain: &str, email: &str, cache_dir: &str) -> Result<()> {
    // 1) 缓存目录（账户与证书缓存，防止频繁注册/限频）
    let cache = DirCache::new(PathBuf::from(cache_dir));

    // 2) 监听 443（TLS-ALPN-01 强制 443）
    let listener = TcpListener::bind("[::]:443").await?;
    let incoming = rustls_acme::tokio::TcpListenerStream::new(listener);

    // 3) 交给 rustls-acme：首次握手时自动下单/挑战/出证，后续自动续期
    let mut tls_incoming = AcmeConfig::new([domain])
        .contact_push(format!("mailto:{email}"))
        .cache(cache)
        .incoming(incoming, Vec::new());

    // 4) 你的业务路由（示例）
    let app = Router::new().route("/", get(|| async { "ELonTalk HTTPS ✅" }));

    // 5) 不停接入 TLS 连接并交给 axum/hyper
    while let Some(conn) = tls_incoming.next().await {
        let conn = conn?;
        let app = app.clone();
        tokio::spawn(async move {
            if let Err(e) = hyper::server::conn::http1::Builder::new()
                .serve_connection(conn, app)
                .await
            {
                eprintln!("serve error: {e}");
            }
        });
    }
    Ok(())
}
```

```rust
// 文件: src/main.rs
//! 根据环境选择 ACME 模式：生产用 TLS-ALPN-01；需要通配或端口受限则走 DNS-01。

mod acme;
mod web; // 你的业务路由，可与上面合并

use anyhow::Result;

#[tokio::main]
async fn main() -> Result<()> {
    let domain = std::env::var("ACME_DOMAIN").unwrap_or_else(|_| "elontalk.duckdns.org".into());
    let email  = std::env::var("ACME_EMAIL").unwrap_or_else(|_| "siwmm@163.com".into());
    let mode   = std::env::var("ACME_MODE").unwrap_or_else(|_| "tls-alpn".into());

    match mode.as_str() {
        "tls-alpn" => {
            // Ubuntu 生产推荐：放行 443，自动申请+续期，零停机
            acme::tls_alpn::run_tls_alpn_server(&domain, &email, "/root/ubuntu-deploy-ready/acme-cache").await?;
        }
        "dns01" => {
            // 如果你选择 DNS-01，这里先签好证，并启动你自己的 TLS 服务器加载 PEM
            acme::dns_duckdns::issue_and_write(&domain).await?;
            // TODO：此处启动你自己的 rustls 服务器，加载 /root/ubuntu-deploy-ready/certs/server.crt / server.key
        }
        other => panic!("未知 ACME_MODE: {other}"),
    }
    Ok(())
}
```

> **生产差异（Ubuntu）**：
>
> * 443 是特权端口。你现在以 root 跑可以直接监听；更稳妥：
>   `setcap 'cap_net_bind_service=+ep' /root/ubuntu-deploy-ready/customer-service-backend`
> * UFW：`ufw allow 443/tcp`
> * **优点**：证书**自动热更新**，无需你手工重启服务；不接触 DNS；最简单可靠。

---

## 路 B：DNS-01 + DuckDNS（支持通配符、端口不受限）

**依赖**：

```toml
# Cargo.toml（关键依赖）
[dependencies]
instant-acme = "0.8"        # 纯Rust ACME客户端
reqwest = { version = "0.12", features = ["rustls-tls"] }
tokio = { version = "1", features = ["full"] }
anyhow = "1"
```

```rust
// 文件: src/acme/dns_duckdns.rs
//! 通过 DuckDNS TXT API 完成 DNS-01 验证，签出（可含通配符）证书，写到 /root/ubuntu-deploy-ready/certs。
//! 之后你的服务器用 rustls 加载 PEM 启动（或文件变更热重载）。

use anyhow::{Result, bail};
use instant_acme::{Account, Identifier, NewOrder, OrderStatus};
use reqwest::Client;
use std::{time::Duration, env, fs};
use tokio::time::sleep;

pub async fn issue_and_write(domain: &str) -> Result<()> {
    let token = env::var("DUCKDNS_TOKEN")
        .map_err(|_| anyhow::anyhow!("缺少环境变量 DUCKDNS_TOKEN"))?;

    // 1) 选择环境：建议先用 STAGING 测试，避免频率限制
    let dir = instant_acme::LETS_ENCRYPT_DIRECTORY_URL; // 生产
    // let dir = instant_acme::LETS_ENCRYPT_STAGING_DIRECTORY_URL; // 测试

    // 2) 创建账户
    let mut account = Account::create(dir)
        .contact(vec![format!("mailto:{}", env::var("ACME_EMAIL").unwrap_or_default())])
        .terms_of_service_agreed(true)
        .create_account()
        .await?;

    // 3) 下单（含通配符）
    let ids = vec![
        Identifier::DnsName(domain.to_string()),
        Identifier::DnsName(format!("*.{domain}")),
    ];
    let mut order = account.new_order(NewOrder { identifiers: ids }).await?;
    let http = Client::new();

    // 4) 对每个授权执行 DNS-01
    for authz in order.authorizations().await? {
        let chall = authz.dns_challenge().expect("必须是 DNS-01");
        let value = chall.dns_value(&account);

        // DuckDNS TXT API：TXT 记录不显示在网页 UI，同一子域可作用于子子域
        let url = format!(
            "https://www.duckdns.org/update?domains={}&token={}&txt={}",
            authz.identifier.value(), token, value
        );
        http.get(&url).send().await?.error_for_status()?;

        // 等待权威 DNS 生效（可适当调大）
        sleep(Duration::from_secs(60)).await;

        chall.validate(&mut account).await?;
    }

    // 5) 等待订单就绪
    loop {
        order.refresh().await?;
        match order.status() {
            OrderStatus::Ready => break,
            OrderStatus::Invalid => bail!("ACME 订单失败"),
            _ => sleep(Duration::from_secs(2)).await,
        }
    }

    // 6) 生成密钥与 CSR，获取证书链
    let pkey = instant_acme::create_p256_key();
    let csr = instant_acme::create_csr(&pkey, &[domain])?;
    order.finalize(csr).await?;
    let fullchain_pem = order.certificate().await?.expect("应返回证书链");

    // 7) 落盘（供你的服务器加载）
    let out = "/root/ubuntu-deploy-ready/certs";
    fs::create_dir_all(out)?;
    fs::write(format!("{out}/server.crt"), &fullchain_pem)?;
    fs::write(format!("{out}/server.key"), pkey.to_sec1_pem())?;

    // 8) 可选清理 TXT
    let clear = format!(
        "https://www.duckdns.org/update?domains={}&token={}&clear=true",
        domain, token
    );
    let _ = http.get(clear).send().await;

    println!("✅ 已写入 {out}/server.crt (fullchain) 与 {out}/server.key");
    Ok(())
}
```

> **运行时**：设置 `DUCKDNS_TOKEN`，`ACME_EMAIL`，然后 `ACME_MODE=dns01`。
> **后续启动**：用 `tokio-rustls`/`axum-server` 读取以上 PEM 启动；续期时可定时（或按到期阈值）再次调用 `issue_and_write`，成功后热重载证书（例如用 `Arc<RwLock<CertifiedKey>>` 或文件变更监听 `notify` crate）。

---

## 🧩 独立模块化怎么做？

* `acme::mod.rs` 只做**配置分发**与**生命周期管理**（如启动 TLS-ALPN 主循环或触发 DNS-01 签发任务）。
* `acme::tls_alpn` 与 `acme::dns_duckdns` **互不依赖**，方便在不同环境开关。
* 通过环境变量或 `.env` 切换：

  * `ACME_MODE=tls-alpn | dns01`
  * `ACME_DOMAIN=elontalk.duckdns.org`
  * `ACME_EMAIL=siwmm@163.com`
  * `DUCKDNS_TOKEN=xxxx`（仅 DNS-01 需要）

---

## 🖥️ Windows 开发 vs Ubuntu 生产：需要区分吗？

**建议区分“策略与端口”，但不必区分代码**，同一套模块即可：

* **Ubuntu 生产**

  * 推荐 `ACME_MODE=tls-alpn`，监听 **443**，一体化自动申请与续期，最省心。
  * `setcap` 赋权或以 root 运行；UFW 放行 443。
  * 优点：证书由库自动热续期，不接触 DNS，流程最稳。

* **Windows 开发**

  * 若只是本地调试：**可以关闭 ACME 模块**（`ACME_MODE=off`），用自签或 HTTP。
  * 若你**想在 Win 上真发正式证书**：

    * 优选 `ACME_MODE=dns01`（不要求 80/443，也不要求域名指到本机）；
    * 把签出的 PEM 上传到服务器即可。
  * 若你要在 Win 上走 TLS-ALPN-01：需要管理员权限监听 **443**，且公网 443 通到你的机器（现实中较麻烦，不推荐）。

**一句话**：**代码不分平台，策略按环境切换**。

---

## 🔒 安全与运维要点

* **DuckDNS Token 切勿硬编码**：放 `/root/ubuntu-deploy-ready/.secrets`，600 权限，通过环境变量注入。
* **证书链用 fullchain**：服务端加载一定要用“站点证书 + 中间证书”的 fullchain，否则浏览器会标“不安全”。
* **频率限制**：先在 **staging** 跑通流程再切生产；缓存目录（路 A 的 `acme-cache`）持久化。
* **自动续期**：

  * 路 A：库自动完成并热替换；
  * 路 B：自己定时（比如每日检查剩余有效期 < 20 天就续期），续期成功后热重载 TLS 证书。

---

如果你确定选择其中一条路（比如 **生产走 `tls-alpn`**，**开发偶尔用 `dns01`**），我可以按你当前的代码结构，补一份**最小可运行的 `main.rs` + `systemd` 服务文件**和**UFW/`setcap` 命令**，完全贴合 `/root/ubuntu-deploy-ready` 目录规范。
